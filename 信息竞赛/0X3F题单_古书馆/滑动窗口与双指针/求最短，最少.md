1.
给你一个二进制字符串 s 和一个正整数 k 
如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。
令 len 等于 最短 美丽子字符串的长度。
返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。
对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。
例如，"abcd" 的字典序大于 "abcc" ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c
- `1 <= s.length <= 100`
- `1 <= k <= s.length`
*<font color="yellow">方法一（枚举）：</font>
枚举每个长度的子串，统计里面1的个数，按字典序比较
时间复杂度：枚举长度N，枚举子串N，比较字典序N，O(N^3)
<font color="yellow">方法二（滑动窗口）:</font>
子串要有k个1，可以用滑窗维护k的个数，做到O(N)找出k个1的子串；
不断枚举右端点，当左端为0或1大于k时就缩小左端点，找出当前右端点最短的子串
把各个答案得出后，用字典序进行比较
时间复杂度：找出首先符合的子串O(N)，比较字典序O(N)，O(N^2)
<font color="yellow">若是整个串都没有k个1，则无解，不然定有解</font>
```c++
    string shortestBeautifulSubstring(string s, int k) {
        //无解情况
        if(count(s.begin(),s.end(),'1') < k)
            return "";
        int left = 0, cnt = 0;
        string ans = s;  //初始化为s，方便后面被比较

        for(int r=0; r<s.size(); r++)
        {
            cnt += s[r]-'0';  //计算窗口1的个数
            //若是多了或是左边可以缩（右边为零时长度更长，不会被选做答案）
            while(cnt > k || s[left] == '0')
                cnt -= s[left++] - '0';
            //此时满足了1小于等于k个，且当前右端点不能再缩了
            if(cnt == k) //满足要求有k个1
            {
                //按长度，字典序比较
                string t = s.substr(left,r-left+1);  //得到当前的窗口
                if(ans.size() > t.size() || ans.size() == t.size() && ans > t)
                    ans = move(t);
            }
        }
        return ans;
    }
```
2.
有一个只含有 `'Q', 'W', 'E', 'R'` 四种字符，且长度为 `n` 的字符串。
假如在该字符串中，这四个字符都恰好出现 `n/4` 次，那么它就是一个「平衡字符串」。
给你一个这样的字符串 `s`，请通过「替换一个子串」的方式，使原字符串 `s` 变成一个「平衡字符串」。
你可以用和「待替换子串」长度相同的 **任何** 其他字符串来完成替换。
请返回待替换子串的最小可能长度。
如果原字符串自身就是一个平衡字符串，则返回 `0`
- `1 <= s.length <= 10^5`
- `s.length` 是 `4` 的倍数
- `s` 中只含有 `'Q'`, `'W'`, `'E'`, `'R'` 四种字符
<font color="yellow">由数据范围size = 4n可知：该串定可以改为平衡串。若改的子串外面已经有某个字符频次超过n/4次，则不论怎么改都不可能成功；反过来说，若子串外面各个字符出现次数都少于n/4，则必定能通过修改，使其平衡</font>
故想到维护一个子串，使其外部各个字符出现次数少于n/4
当子串**R向右**时，外部频次降低，**越满足**成为平衡串；**L向右**时，外部频次增大，**越不满足**成为平衡串
故有了单调性，可想到滑动窗口：
不同的是，这里**R往右是越满足**，**L往右是越不满足**，我们要找**最短**的子串
那么一开始就已经满足了（即全改）
但我想要**更短**的串，于是从不改到开始，**右移R到满足为止**；再**右移L直至不满足**，得到对于此时R最短的串R-(L-1)+1；
此时**刚好**不满足，不断右移R直至满足，对于R，L不可能左移，因为 ->
<font color="yellow">这个R我不要，在R-1的基础上L往左，就会满足条件，这里R又是使其满足条件，那么为何不要那个更短的呢？</font>

综上发现：
第一题两个指针LR分别对应：R往右是不满足，L往右是满足，L不往左是因为再往左一定不满足
第二题两个指针LR分别对应：R往右是满足，L往右是不满足，L不往左是因为为何不要更短的
个人猜想（还没做到那，今早做第二题脑子被卡了，于是有了这玩意）：
若L往右是满足，L往右也是满足，则L一定往左走
若L往右是不满足，L往右也是不满足，则L一定往左走
```c++
    int balancedString(string s)
    {
        int n = s.size()/4, cnt['Z']{};
        for(char c : s)
            cnt[c]++;
        //若是已经满足，就直接返回0
        if(cnt['Q'] == n && cnt['W'] == n && cnt['E'] == n && cnt['R'] == n)
            return 0;
        //因为全改必有解，ans设置为长度，找更短的解，故要特判一开始就满足的情况
        int ans = s.size(), l = 0;
        for(int r=0; r<s.size(); r++)
        {
            --cnt[s[r]];  //右移，直至满足
            //过程中取答案，循环结束就不满足了，右移左端点
            //不要去搞花招，ans老实写里面
            while(cnt['Q'] <= n && cnt['W'] <= n && cnt['E'] <= n && cnt['R'] <= n)
            {
                ans = min(ans,r-l+1);
                ++cnt[s[l++]];
            }
        }
        return ans;
    }
```

给你一个下标从 **0** 开始的数组 `nums` 和一个整数 `target` 。
下标从 **0** 开始的数组 `infinite_nums` 是通过无限地将 nums 的元素追加到自己之后生成的。
请你从 `infinite_nums` 中找出满足 **元素和** 等于 `target` 的 **最短** 子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 `-1`
<font color="yellow">我们容易发现子数组R越大，sum越大，L越大，sum越小（单调性），考虑滑窗找出最短的那个子数组？但这有个问题，数组是循环的，R终止点在哪呢？无从下手。但由于数组只是简单的首位相接形成循环，我们看看取模有没有什么妙用？</font>

<font color="yellow">如果只是对指针取模，顶多解决了循环数组遍历的问题，对于R终止点没有帮助。那我们不止对指针取模，试试对区间的值（目的）取模会怎样？取谁的模？R终止点无法确定是因为不知道到底要经历多少个循环数组，那取循环数组的模吗？若如此，用target MOD sumArray会得删去子数组中间的整段区域，只得到两头在首，末循环数组的元素和，即target2，由此一来我们求连续的两个循环数组中元素和为target2的最小子数组，再加上中间的整段长度即可</font>
```c++
    //注意，由于有多值相加，且数值不小，要开long long保险
    //ans可以不开long long 但all必须要开
    int minSizeSubarray(vector<int>& nums, int target) {
        long long n = nums.size(), all = 0;
        for(auto& x : nums)
            all += x;
        //中间的很有规律，可以直接用数学计算，管两头就行
        //在剩下的两头里找到剩下需要凑的数即可
        long long target2 = target % all, sum = 0, l = 0, ans = LLONG_MAX;
        for(int r=0; r<2*n; r++)  //要写2*n，不然只循环到一个数组了
        {
            //两个数组真的要连一块吗？不需要，取模%可以解决循环的问题
            sum += nums[r%n];
            while(sum > target2)
                sum -= nums[(l++)%n];
            if(sum == target2)
                ans = min(r-l+1,ans);
        }
        return ans == INT_MAX ? -1 : ans + target/all*n;
    }
```
``